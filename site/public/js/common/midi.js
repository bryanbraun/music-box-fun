import { initialState } from '../state.js';
import { musicBoxStore } from '../music-box-store.js';
import { cloneDeep } from '../utils.js';
import { forEachNotes, clearAllExistingNotes, dedupeAndSortSongData } from './notes.js';
import { PULSE_PER_QUARTER_NOTE, NOTE_DURATION_IN_TICKS, TICKS_PER_PIXEL, DEFAULT_SONG_TITLE, NOTE_LINE_STARTING_GAP, MAX_TEMPO } from '../constants.js';

// Midi export function songState → Blob
// Midi import function Blob → songState
export async function getSongStateFromMidiBlob(midiBlob) {
  // Initialize new song state by clearing existing notes. For simplicity, we import the
  // song into *the current music box type*, and warn the user if any notes were dropped.
  const midiData = await midiBlob.arrayBuffer();
  const { Midi } = await import('../vendor/@tonejs/midi.js');
  const midi = new Midi(midiData);

  let newSongState = cloneDeep(initialState).songState;
  newSongState.songData = clearAllExistingNotes(musicBoxStore.state.songState.songData);
  newSongState.tempo = Math.min(Math.round(midi.header.tempos[0].bpm), MAX_TEMPO) || DEFAULT_TEMPO;
  newSongState.songTitle = getValidSongTitle(midi.header.name);

  const excludedInstrumentFamilies = ['percussive', 'sound effects'];
  let someNotesCouldNotBeImported = false;

  midi.tracks.forEach(track => {
    if (excludedInstrumentFamilies.includes(track.instrument.family)) return;

    track.notes.forEach(note => {
      if (newSongState.songData[note.name] === undefined) {
        someNotesCouldNotBeImported = true;
        return; // Skip any notes that are not supported by the chosen music box.
      }

      let notePositionInMusicBoxFunTicks = (PULSE_PER_QUARTER_NOTE / midi.header.ppq) * note.ticks;
      const yPos = Math.round(notePositionInMusicBoxFunTicks / TICKS_PER_PIXEL) + NOTE_LINE_STARTING_GAP;
      newSongState.songData[note.name].push(yPos);
    });
  });

  newSongState.songData = dedupeAndSortSongData(newSongState.songData);

  return [newSongState, { someNotesCouldNotBeImported }];
}

export async function getMidiBlobFromSongState(songState) {
  const songData = songState.songData;
  const tempo = songState.tempo;
  const songTitle = songState.songTitle || DEFAULT_SONG_TITLE;

  const { Midi } = await import('../vendor/@tonejs/midi.js');

  // Create a MIDI file
  const midi = new Midi();
  midi.header.fromJSON({
    name: songTitle,
    ppq: PULSE_PER_QUARTER_NOTE,
    tempos: [
      {
        bpm: tempo,
        ticks: 0
      }
    ],
    timeSignatures: [
      {
        timeSignature: [4, 4],
        ticks: 0
      }
    ],
    keySignatures: [],
    meta: [{
      text: 'Song generated by Music Box Fun.',
      type: 'text'
    }]
  });

  // Add a track
  const track = midi.addTrack();
  track.name = "Music Box";
  track.instrument.name = "music box";

  // Add notes to the track
  Object.keys(songData).forEach(pitchId => {
    forEachNotes(songData[pitchId], (yPos) => {
      const yPosWithoutStartingGap = Math.max(0, yPos - NOTE_LINE_STARTING_GAP);
      const ticksPosition = yPosWithoutStartingGap * TICKS_PER_PIXEL;

      track.addNote({
        name: pitchId,
        ticks: ticksPosition,
        durationTicks: NOTE_DURATION_IN_TICKS
      });
    });
  });

  // Return the MIDI file as a Blob
  const midiData = midi.toArray();
  return new Blob([midiData], { type: 'audio/midi' });
}

// Some apps/tools export inaccurate song titles, so we check for those here.
function getValidSongTitle(midiTitle) {
  const inaccurateSongTitles = ['MusicBoxManiacs.com'];
  return inaccurateSongTitles.includes(midiTitle) ? "" : (midiTitle || "");
}
